<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>       
        </para>
<para>
A programozási nyelveket több szempont szerint csoportosíthatjuk. Ha aszerint nézzük, hogy mennyire férünk hozzá a gép hardveréhez a kóddal, akkor 3 szintet különbözünk meg: a gépi kódot, assembly és a magas szintű nyelveket.  A magas szintű nyelven írt kódot forráskódnak hívjuk, és ennek a felépítését nyelvtani és tartalmi szabályok együttese határozza meg, amit hivatkozási nyelvnek nevezünk. A processzor alapvetően gépi kódokat tud értelmezni, ezért a magas szintű nyelven írt kódokat valamilyen módszerrel át kell alakítanunk, hogy futtatni tudjuk. Erre vagy fordítóprogramos (pl. C) vagy interpreteres (pl. Python) megoldást használunk, esetenként mindkettőt.  A fordítóprogram a kódból csinál egy tárgyprogramot, amit egységként kezel és bizonyos lépésekkel gépi kódot készít belőle. Az interpreteres verzióban nincs tárgyprogram, soronként értelmezi és végrehajtja a programot. A különböző platformokra megírt fordítóprogramokat és interpreterek implementációknak nevezzük, ezeknek a nagy problémája a kompatibilitás egymással, illetve akár a hivatkozási nyelvel is. Aszerint is lehet a nyelveket csoportosítani, hogy algoritmussal vagy anélkül (pl. probléma megadással) írjuk le őket, eszerint léteznek az imperatív nyelvek (pl. objektumorientált nyelvek) és a deklaratív nyelvek (pl. logikai nyelvek). 
</para>
<para>
Az adattípusok absztrakt programozási eszközök, amiket valamilyen konkrét programozási eszköz részeként használunk. Vannak olyan nyelvek, amelyek használnak adattípusokat és vannak, amelyek nem. Három fő tulajdonságuk van: a tartomány azon részei az adatszerkezetnek, amelyeket a konkrét programozási eszközök felvehetnek értékül.  A műveletek tulajdonság, az ilyen tartomány elemekkel végezhető műveleteket jelöli. A reprezentáció tulajdonság pedig azt jelöli hol tároljuk a memóriában és mekkora méretben. Egy nyelvben általában előre meg vannak határozva a használható adattípusok, de néhány esetben lehetőség van saját típusok létrehozására is. (pl. C). Lehetőség van arra is, hogy egy adattípusból létrehozzunk egy altípust a tartományának csökkentésével.  Az adattípusokat alapvetően két nagy csoportra oszthatjuk: az egyszerű típusúak (pl. egész, valós, logikai) tartománya olyan értékeket tartalmaz, amelyek egyediek, az összetett típusúak (pl. tömb, rekord, mutató) tartományának értekeinek típusa van. 
</para>
<para>
A nevesített konstans egy olyan eszköz, amit akkor használunk, ha egy értéket sokat kell majd használni a program során, de változtatnunk nem kell rajta. Három részből áll, van neve típusa és érteke. 
</para>
<para>
A változóknak már 4 tulajdonsága van. Ugyanúgy van értéke és neve, de már azt is megadhatjuk, hol helyezkedik el a memóriában, ami a cím tulajdonság, emellett van egy attribútum tulajdonsága ilyen pl. a típus. Az attribútumokat deklaráció során állítjuk be a legtöbb esetben. A deklaráció lehet manuális (explicit), betűkhöz rendelhetünk attribútumokat és az adott kezdőbetűjű változók kapják meg őket (implicit) és történhet a fordítóprogram által (automatikus). A címkiosztásnak is több módja van: lehet már futás előtti (statikus), végezheti a rendszer a program adott állapotától függően (dinamikis) és megadhatjuk mi is. A kezdőérték utasítás is lehet különböző megadhatjuk manuálisan, de néhány esetben, ha ezt nem tesszük meg akkor a fordítóprogram ad meg egy címet, hogy nem memóriaszemét legyen a helyén. C-ben az egyszerű típusokat aritmetikainak az összetett típusokat származtatottnak nevezzük. Fontos megemlíteni, hogy a karakter típusoknak van egy beépített szám értéke, illetve a logikai típus nem élérhető, és a logikai kifejezések egészekkel vannak megoldva (0-igaz, minden más-hamis). A rekordokat általában struktúrákkal ábrázoljuk. 
</para>
<para>
A kifejezéseket arra használjuk, hogy adott értékeknek új értékeket adjunk a programban. Állnak operandusokból, amik lehetnek változók, konstansok és függvényhívások, illetve operátorokból, amik a műveleti jelek. Szükség esetén zárójeleket is használhatunk. Az kifejezéseket megkülönböztetjük aszerint, hogy hány operandust használnak. Ezen kívül alakjuk is változhat lehet: prefix (* a b), infix (a * b), postfix (a b *). A magas szintű nyelveben általában infix alakot használjuk, de például a lisp nyelv a prefix alakot használja. A műveletek feldolgozási sorrendje is alakfüggő, infix-ben ez nem egyértelmű ezért használunk precedencia táblázatot és zárójeleket. Néhány nyelvben léteznek úgynevezett rövidzár operátorok, amiknél nem kell az egész kifejezést kiértékelni, hogy megkapjuk az eredményt. (pl. és operátor). Nyelvenként változik az is, hogy egy kifejezésnél csak azonos típusú vagy különböző típusú operandusokkal végzünk műveleteket. Utóbbi esetben lényeges megemlíteni, hogy ez típuskonverzió segítségével jön lére. 
</para>
<para>
Az utasítások a programozási nyelvek nélkülözhetetlen elmei. Két nagy csoportjuk van a deklarációs és a végrehajtandó utasítások.  A deklarációs utasítások, azok az utasítások, ahol, változókat, konstansokat stb. deklarálunk. A végrehajtandó utasításoknak már több csoportja létezik. Egy nagyobb csoport a vezérlési szerkezetet megvalósító utasítások. Ide soroljuk pl. amikor értéket adunk valamilyen változónak vagy konstansnak, az elágazásokat biztosító utasításokat tehát az if-et vagy több elágazás esetén a switch-et. Megemlíthető még az ugró utasítás (goto) is, de annak használatát már tudjuk helyettesíteni és néhány esetben veszélyes lehet. A következő csoport azok az utasítások, amikkel egy tevékenységet többször is végrehajthatunk, tehát a ciklus utasítások. Ezeken belül még többféle csoportosítás lehetséges. A legfontosabb megemlíteni azt, hogy a ciklus elől vagy hátul tesztelő. Az elöl tesztelő esetben a ciklus először vizsgálja a feltétételt majd fut le, míg a hátul tesztelő esetén minden esetben lefut legalább egyszer az utasításblokk majd utána nézi a ciklus a feltételt. A tipikus példa az elől, illetve hátul tesztelő ciklusra a while és a do-while. Ezen kívül még néhány ciklusnak meghatározhatjuk hány futás történjen, ilyen esetben viszont mindig ciklusváltozót használunk a fejében. 
</para>
<para>
Az, hogy a programunkat, hogy tagoljuk nyelvenként változik. Vannak nyelvek, amelyekben külön-külön fordítható önálló részeket írhatunk míg más nyelvekben egységként fordítjuk a kódot és csak annak a belső részeit mélyíthetjük, illetve létezik ezek kombinációja is. Az alprogramok az eljárásorientált nyelvekben jelennek meg, arra használjuk őket, ha a program egy részét többször szeretnénk használni. Az ilyen alprogramokban általánosan megírjuk minek kell történnie és ezt a főprogramban csak meghívjuk ahányszor csak szükséges. Az alprogramokban formális paramétereket használunk. Két típust különböztetünk meg: az eljárásokat és a függvényeket. Az eljárás valamilyen tevékenységet végrehajt és az eredményét tudjuk használni a meghívott helyen. A függvények mindig valamilyen értéket adnak vissza, ezt visszatérési értéknek nevezzük és a függvény deklarálásakor meghatározzuk a típusát. Fontos megemlíteni, hogy az itt deklarált változók lokálisak, tehát csak itt használhatók a programban. Hívási láncnak vagy rekurziónak nevezzük azt a jelenséget, ha egy programrészben egy másik programrészt meghívunk. Nincs meghatározva hány rekurzív hívás van „összefűzve”.   A programrészben meghívhatjuk önmagát vagy már egy korábban meghívott részt. 
</para>
<para>
A paraméterátadás a programrészek közötti kommunikáció egy módja. Két résztvevője van: a hívó és a hívott, a hívó lehet akármilyen programrész, a hívott viszont csak alprogram lehet. A paraméterátadást az információ iránya, tartalma szerint csoportosítjuk. A C-ben az érték szerinti átadást használjuk. Az érték szerinti átadáskor a formális karakter megkapja az adott értéket, ilyenkor értékmásolás történik. Ez csak akkor lehetséges, ha az alprogramban a formális paraméternek van címe. Az érték átadódik és ezzel az alprogram a saját területén dolgozik, tehát az információ áramlás csak egyirányú. Hátránya, hogy lassú lehet nagyobb adatcsoportok másolásánál. A C++-ban már megjelent a referencia szerinti átadás is. 
</para>
<para>
A blokk egy másik program belsejében elhelyezkedő programegység, amely tetszőleges utasításokat tartalmaz. A kezdetét és végét valamilyen speciális karakter jelöli. Rákerülhet automatikusan a vezérlés vagy ráléphetünk goto utasítással. 
A változóknak, konstansoknak, adatszerkezeteknek stb. van egy hatásköre, ami azt jelenti, hogy a program mely részein értelmezhető, végezhetők vele műveletek. Ennek beállítása két módon történhet: statikus és dinamikus. Statikus esetben a fordítóprogram dolgozik, végigmegy a kódon és egyes programrészekre megnézi lokális-e az adott név. Ezt addig csinálja amíg el nem érjük a legkülső részét a programnak. Ilyenkor kaphatunk hibát vagy deklarálódhat automatikusan a név. Az ilyen módú beállításnál az adott programrészben deklarált változók lokálisak. Ha nem ott deklaráltuk őket, de elérhetőek akkor pedig globálisak. A dinamikus megoldásban úgynevezett hívási láncot használunk. Az deklarált változók hatásköre a deklarálásuk helyének programrésze és minden olyan programrész, ami ezzel hívási láncban van. Az ilyen hatáskörkezelést a futtató rendszer végzi. 
</para>
<para>
Az input-output kezelés a legtöbb programozási nyelvnél változik, azonban a legtöbb nyelvre jellemző, hogy középpontjában az állomány áll. Ez áll egy fizikai és logikai részből és funkciója szerint csoportosítjuk. Az input állományból csak olvasni lehet és már létezik. Az output állomány nem létezik a létrehozása előtt és ebbe csak írni lehet. Az input-output állományok ennek keveréke, lehet olvasni-írni és létezik feldolgozás előtt, de a tartalmát megváltoztathatjuk. Az állományokból való munka több lépésből áll: a logikai részt deklarálni kell, majd megfeleltetni a fizikai állománnyal. Ezt követően tudjuk megnyitni, feldolgozni, majd lezárni. A C-ben az I/O műveletek alapból nem részei a nyelvnek, standard könyvtári függvényeket használunk hozzájuk.  
</para>
<para>
A kivételkezelés arra szolgál, hogy a megszakításoknak a kezelését a program szintjén tudjuk végrehajtani. Egy megadott esemény után lép életbe, arra az eseményre reagálva. A bizonyos kivételek kezelése letiltható és engedélyezhető. 
</para>
<para>
A programok alapvetően szekvenciálisak tehát sorrendben hajták végre az utasításokat. Az erőforráshasználatnak megfelelően a programokat csoportosíthatjuk szálakra és folyamatokra. A folyamatok csak külön-külön míg a szálak közösen birtokolhatják az adott erőforrásokat. A szálak kommunikálnak egymással, időközönként találkoznak és adatcserét hajthatnak végre és egymással versenyben vannak az erőforrásokért. Biztosítanunk kell, hogy ne használjanak egy időben adatokat pl. az egyik változtatja a másik felveszi értékül. 
</para>
    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
<para>
A C-ben, mint sok más nyelvben a változókat aszerint csoportosítjuk, hogy milyen értéket tárolunk bennük. A számokat két csoportra oszthatjuk, az egészekre és a törtekre. Az egészeket tároló változó az int, ehhez tartozhatnak szimbólumok, amelyek a méretét változtatják. Ezek a short, long és az unsigned. A számokhoz tartoznak még a törteket tartalmazó változók, ezeknek két típusa van a float és a double. A float-ban 7, a double-ben pedig 14 tizedespontosságig tárolhatjuk a törteket. Emellett van a char típus, ami egy karakternyi értéket tárol. C-ben minden változót deklarálnunk kell a használata előtt. A változók bitmérete viszont változhat. Ha globális konstansokat akarunk létrehozni, akkor arra azt definiálnunk kell. Ezt a program során nem változtathatjuk meg, akkor szoktuk használni, ha egy értékkel sokat számolunk, de nem változtatjuk az értékét. 
</para>
<para>
A nyelv vezérlésátadó utasításai azt mondják meg mikor kerül egy utasításra sor a lefutás során. 
A C-ben a következő vezérlésátadó utasítások szerepelnek: 
If utasítást akkor használunk a programban, ha többféle lehetőséget szeretnénk megadni a kifejezés kimenetétől függően. A gép kiértékeli az if fejében lévő kiértékelést majd, ha igazat kapott végrehajtja az utasítást.  Ha nem igaz értéket kapott alap esetben nem történik semmi, de írhatunk egy else ágat, amivel az ilyen esetekre adunk megoldást. Az if-else ágakat akármeddig fűzhetjük egymásba viszont ez nem ajánlott mert bonyolult nehezen érthető kódot kapunk. Ha mégis használunk egymásba ágyazott if-else kifejezéseket, akkor fontos megemlíteni, hogy az else a hozzá legközelebbi if-hez tartozik. 
A switch utasítással egymásba ágyazott if-else-eket valósíthatunk meg elegánsabb módon. A fejében ugyanúgy van egy kifejezés, ami kiért ékelődik majd egyezéseket keres a megadott case-ekkel. Ezek a case-ek egymástól különböző egész értékek lehetnek és hozzájuk utasításblokkok tartoznak, amelyeket break utasításokkal zárunk. A program sorban halad és egyezéseket keres a case-ekben a kifejezés értékével és ha talál lefuttatja hozzá tartozó utasítást. Ha nem talál a default utasítás fut le.  
A while utasításban a gép kiértékeli a fejben található kifejezést, majd, ha az értéke nem nulla, akkor végrehajtja az adott utasítást és ismételten kiértékel. Addig zajlik ez az értékelés és futtatás amíg a megadott kifejezésre nem kapunk nullát. 
A for utasítás három részből áll, amelyek mindegyike egy kifejezés. Ezek általában következőképpen néznek ki: Az első kifejezésben deklarálunk egy ciklusváltozót, amit a harmadikban növelünk, a második kifejezés pedig egy a ciklusváltozóhoz köthető relációs kifejezés. Ezek bármelyike elhagyható, de az utána következő pontosvesszőt ki kell raknunk, viszont, ha relációs kifejezést hagyjuk ki akkor a ciklus végtelen lesz. 
A do-while utasítás a vizsgálatot a ciklus végén az utasítások végrehajtása után végzi el, tehát legalább egyszer mindig végrehajtódnak az utasításai.  A gép először végrehajtja az utasításokat, majd kiértékeli a kifejezést. Ha a kifejezés értéke hamis lesz akkor ér véget a ciklus, pontosan úgy, mint a sima while ciklus esetében. 
A break utasítást arra használjuk, hogy egy ciklusból való kilépést ne a relációs utasítással vezérlejük. A break-el a vizsgálat előtt is ki lehet ugrani egy for, while vagy do-while ciklusból, vagy akár switch-ből. A break utasítás hatásra a vezérlés azonnal kilép a legbelső zárt ciklusból. 
A continue utasítás szorosan kapcsolódik a break-hez, de kevesebbet használjuk. A continue utasítás hatására a ciklus következő részére ugrik a vezérlés, for esetén az újra inicializálásra. 
A goto utasítással címkékre ugorhatuk, olyan esetekben használjuk a legtöbb esetben, ha egymásba ágyazott ciklusokból akarunk kilépni. A használata nem ajánlott veszélyes lehet.  
</para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para>        
    </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
<para>
A C++ a C nyelv egy továbbfejlesztése, az újítások közül sok a C-ben esetlegesen nem biztonságos elemeket cseréli megbízhatóbbra. A C++ nem objektumorientált újításai az alábbiak: 
Ha egy függvénynek nem adunk paramétereket akkor az a C-től eltérően, ahol ilyen esetben akármennyi paramétert megadhattunk, itt azt jelenti, hogy a paraméterlista üres. Ezen kívül kikerült még a nyelvből az alapértelmezett visszatérési érték, minden nem void típusú függvénynél meg kell adnunk. Kivétel erre a main () függvény amire a fordítóprogram a return hiányában return 0; -t fordít. 
Fontos újítás a bool típus megjelenése, a C-ben a logikai értékeket int vagy enum típusokkal tárolták, C++ -ban erre már ott van bool típus ami igaz, vagy hamis értéket vehet fel. 
Bekerült a több bájtos stringek (pl. UNICODE karakterek) tárolására alkalmas wchar típus, amit C-ben csak bizonyos könyvtárak használata mellett tudtunk alkalmazni. A változódeklarációk már mindenhol szerepelhetnek, deklarálhatunk változókat közvetlenül a használatuk előtt.
Lehetőség van a függvénynevek túlterhelésére is. C-ben a függvényeket a neve azonosítja egyértelműen ezért a hatáskörén belül nem lehet egy másik ugyanolyan nevűt létrehozni. Erre már a C++-ban van lehetőség, mert itt a függvényeket nem csak a nevük, hanem a paraméterlistájuk szerint csoportosítjuk. Ennek az az egyik előnye, hogy nem kell mindig új már-már erőltetett függvényneveket kitalálni.  A fordító a névferdítés technikával különbözteti meg őket.  Lehetőség van arra is, hogy a függvényeknek paramétereinek megadjuk alapértelmezett értékeket, arra az esetre, ha nem kapnak értéket.
A C-ben, ha paraméterként átadtunk egy változót akkor azt érték szerinti átadással tehettük. És az a paramétert a függvényen belül nem változtathattuk, csak akkor, ha pointereket használunk a függvényben, ami az érték szerinti paraméterátadás. A C++-ban lehetőségünk van a referencia szerinti paraméterátadásra, mivel bekerült a referencia típus is. Ilyen típust a referencia neve elé írt <quote>&amp;</quote> jellel hozunk létre, a referencia típusának megfelelő változóval. Ha a referencia változik az eredeti változó is fog. Ezt a típust általában a cím szerinti paraméterátadásnál szoktuk használni, mert ha a változókra hivatkoznánk így a kódot áltáthatatlanná tenné. 

</para>
<para>
Az objektumorientált programozás egyik alapelve az egységbe zárás, ami annyit jelent, hogy akármiből csinálhatunk egy adatstruktúrát, a hozzá tartozó tulajdonságokkal. Ezt az adatstruktúrát osztálynak nevezzük. Az osztályok példányait objektumoknak nevezzük, és fontos tulajdonságuk az adatrejtés, ami annyit jelent, hogy egyes elemek nem férnek hozzá a többi elemhez. Lehetőségünk van az öröklődésre tehát létrehozhatunk speciális osztályokat az osztályokon belül, amik örökölik az alap osztály tulajdonságait. pl. a dolgozó osztályon belül lehet egy eladó osztály. Amikor egy ilyen osztályt példányosítunk egy új objektumot hozunk létre. Ezek az objektumorientáltság alapelvei.
Az osztályokon belül létrehozott változókat tagváltozóknak a függvényeket tagfüggvényeknek nevezzük. Ha egy változót deklarálunk az adott osztályból minden tagváltozónak törtőnik memóriafoglalás. A tagfüggvényeket deklarálhatjuk a struktúrán belül és a törzsét a struktúrán kívül. A tagváltozókkal ellentétben tagfüggvények csak egy példában foglalnak helyet a memóriában.
Az adatok elrejtésére a private kulcsszót használjuk a private: után felsorolt tagváltozók és függvények csak az osztályban lesznek láthatók és tagfüggvényekkel férhetünk hozzájuk. 
Az objektumok fontos része a konstruktor, amivel példányosításkor inicializálni tudjuk az objektumunkat. Egy speciális függvény, ami minden egyes példányosításkor meghívódik.  Egyszerre többet is írhatunk egy objektumhoz, ha nem írunk egyet sem akkor a fordítóprogram alapértelmezetten ír egyet, ami semmit nem csinál.  A konstruktor párja a destruktor, ami akkor hívódik meg, ha egy objektum megszűnik.  Ez az objektum által használt erőforrásokat szabadítja fel.  
C-ben a dinamikus memóriakezelés a malloc é a free függvények használatával oldottuk meg. A malloc függvény viszont nem teszt különbséget a típusok között és az objektumok memória foglalására képtelen. C++ -ban ezeket oldja a meg a new és a delete függvény.  Osztályok esetén a new függvény után, ha üres zárójelet használunk a paraméter nélküli konstruktor esetében, ha a konstruktornak vannak paraméterei azokat meg kell adnunk a new függvényben. 
A konstruktor egy speciális típusa a másolókonstruktor. Ugyanúgy működik, mint más konstruktorok, de az objektum inicializálásakor egy másik már létező objektumot másol le. 
A C++-ban lehetőség van arra, hogy egy osztály feljogosítson más osztályokat vagy függvényeket, hogy a védett részeihez hozzáférjenek. Ha a függvény elé írjuk a friend kulcsszót akkor az adott függvénynek olyan jogai vannak az osztály részeinek hozzáféréséhez, mintha az adott osztály tagfüggvénye lenne. 
Készíthetünk friend osztályokat is, amik hozzá tudnak férni az adott osztály védett elemeihez. 
A friend viszony nem sérti a védett elemek elvét, hiszen csak korlátozott módon férhetünk hozzájuk és ritkán alkalmazzuk. 
A statikus változók olyan változók az osztályban, amelyek az adott osztályhoz tartoznak és nem változnak példányosított objektumonként, akkor is használhatók, ha még az osztály még nem példányosítottunk egy objektumot sem. Használhatunk statikus tagfüggvényeket is, előnye, hogy objektum nélkül tudjuk használni, viszont csak az osztály statikus részeit éri el. 
A C++-ban megadhatunk osztályon belüli típusdefiníciókat, amiket beágyazott definícióknak nevezünk. Ezeknek az elérhetősége az osztály elérhetőségétől függ. 

</para>
<para>
A C++ -ban a matematikai műveleteket az operátorok végzik.  Ezek a beépített típusokra érvényesek, ahhoz, hogy a saját típusainkon használjuk őket úgynevezett túlterhelést kell alkalmazni. Ezeknek az operátoroknak van egy alap végrehajtódási sorrendje, amit zárójelekkel manipulálhatunk. Ezen kívül van egy argumentumok és egy visszatérési értékük. A C++-ban megjelent néhány új operátor is pl.: a hatáskör operátor és a pointer-tag operátor. Itt az operátorokat felfoghatjuk úgy, egy speciális függvény és sajátot is írhatunk, de ennek nem az a célja, hogy már a jól bevált operátorokat újraírjuk hanem hogy alkalmazni tudjuk az operátorokat a saját típusainkon. Mivel az operátorok is függvények ezért úgy terheljük túl őket, mint egy függvényt. 
</para>
<para>
A C-nyelvben bekérésre és kiíratásra magas szintű állományleírókat használtunk (stdin, stdout) a C++-ban már adatfolyamok (cout, cin) állnak a rendelkezésünkre, amik a bitenkénti balra és jobbratolás operátorait használják. A típusleíró formátumstringekkel sem kell bajlódnunk a >> operátor automatikusan felismeri az adott típust. A cin alapvetően a „.” -ig olvas egész számokat, ha ezt meg akarjuk változtatni az ignore függvényt kell használunk, ahol beállíthatjuk, hogy mi legyen az olvasási limit. Mivel ezek a kiírások és beolvasások rendszerhívásokat alkalmaznak, amik költésége magas, ezért buffer-eket rendelnek hozzájuk. Ha több cout kiíratás van a programban akkor előbb összegyűjti a szükséges adatokat és egy rendszerhívást használ rájuk. A buffer-ek kiürítésre a flush () függvényt használjuk vagy küldhetünk hibaüzeneteket a cerr objektumból. És ha hibát kapunk a beolvasás ugyan lefut, de nem csinál semmit. A C++-ban már a string-ek is megjelennek, ezek olvasására is használhatjuk a >> operátort, de a szóközt tartalmazó string-et akarunk beolvasni azt a getline () függvénnyel tehetjük. 
Az adatfolyamoknak vannak tagfüggvényei, amelyekkel olvashatjuk, írhatjuk őket, de ez nem az egyetlen mód a megváltoztatásukra.  Végezhetjük ezeket manipulátorokkal is, amik speciális objektumok. Ilyen manipulátor pl. az endl (sortörés) vagy az ignorews (szóköz figyelmen kívül hagyása).  Szöveg formázására is használhatunk tagfüggvényeket és manipulátorokat. Az állománykezelés is adatfolyamok által működik (ifstream, ofstream). Ezeket osztályok reprezentálnak. A megnyitásukat és bezárásukat végezhetik a konstruktorok és destruktorok vagy használhatunk rájuk open és close függvények. 

</para>
<para>
A C++ -ban a hibák kezelésére a kivételkezelést alkalmazzuk. A kivétel érzékelésekor a vezérlés rögtön a kivételkezelőre ugrik. A kivételkezelést a try-catch blokkal oldjuk meg. A try {} -ei között lévő blokk a védett blokk, amiben, ha nem találunk hibát minden utasítása lefut. Ha találunk kivételt, akkor azt throw függvénnyel eldobjuk és az a catch függvény elkapja, amelynek megegyeznek a paraméterei. A try-catch blokkokat egymásba is ágyazhatjuk így különböző szinteken oldhatjuk meg a kivételkezelést. Ha a throw-nak nem adunk meg paraméter a kivétel újra dobható lesz. 
A könyv 190. oldalán egy olyan programban alkalmazzuk a try catch párost, ami egy szám reciprokját adja meg, és a bekért szám nem lehet 0-mert, akkor 0-val való osztás történne. 
A könyv 197. odalán lévő példában az úgynevezett verem visszacsévélése folyamatot láthatjuk, ami annyit tesz, hogy a kivétel dobása után amíg az elkapás meg nem történik egy hívási láncban haladunk felfelé és a lokális függvények változóit felszabadítjuk. 

</para>
    </section>        
</chapter>                
