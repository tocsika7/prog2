<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>A Mandelbrot halmaz</title>
		<para>
		A feladatban tutoriáltam: Borvíz Róbert <link xlink:href="https://github.com/BorvizRobi/prog_1_textbook/tree/master/beadando">https://github.com/BorvizRobi/prog_1_textbook/tree/master/beadando</link>
		</para>
        <para>
         A Mandelbrot halmazt Benoît Mandelbrot fedezte fel és róla nevezték el 1982-ben. A halmazt olyan komplex számok alkotják melyek sorozata nem tart a végtelenbe. Ha a halmazt ábrázoljuk a komplex számsíkon egy jellegzetes
		ún. fraktál alakzatot kapunk. A halmazt úgy kapjuk meg, hogy felveszünk a komplex számsíkon egy rácsot, majd kiszámojuk, hogy a rács adott pontja melyik komplex számnak felel meg. Megvizsgáljuk a rács pontjait a 
		z<subscript>n+1</subscript>=z<subscript>n</subscript><superscript>2</superscript>+c képlet segítségvel, amelyben a c az adott rácspont a z0 pedig az origó. Elmegyünk az origótól (z0) tól a z1 = c ig. Majd a c-től függően
		további z-kbe. Ha ez az urgás kivezet egy 2 sugarú körből akkor az nem a Mandelbrot halmaz része, ha benne marad ebben a tartományban akkor pedig igen.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/tocsika7/prog1/blob/master/Mandelbrot/mandel.cpp">https://gitlab.com/tocsika7/prog1/blob/master/Mandelbrot/mandel.cpp</link>               
        </para>
		<para>
		A program lényegi részét a mandel() függvénybe írjuk, amelynek a paraméterei a kép méretei.
		Deklaráljuk a szükséges változókat, majd egy dupla for ciklussal véggimegyünk a kép szélességén és magasságán. 
		Mivel itt nem használjuk a komplex osztályt, ezért itt két változó lesz egy komplex szám valós és képzetes részei. (reC, imC illetve reZ, imZ).
		A reC és imC a rács csomópontjának megfelő komplex szám lesz, ami képletben a c. A reZ és az imZ a képletben
		szereplő z értéknek felelnek meg. Alkalmazzuk a fent említett képletet addig, ameddig a z abszolút értéke kisebb, mint 2 vagy elérjük az iterációs határt. 
		Ha ez megtörtént átadjuk a kép paramétereinek az adott iterációt, mivel az adott komplex szám a halmaz eleme. A main() függvényben ellenőrizzük jól van-e használva a program: csak akkor 			fut ha helyesen, ha
		2 paramétert adunk meg parancssori argumentumként (fájlnév, menteni való kép neve). Ellenkező esetben a helyes használatot írja ki. 
		Alkalmazzuk a mandel() függvényt a kép adatain, amit a png++-al hozunk létre. Majd végigmegyünk a kép szélességén  és magasságán és beállítjuk a kívánt színeket set_pixel() függvénnyel. 
		</para>
		<programlisting language="c"><![CDATA[
		// mandelpngt.c++
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
//  Mandelbrot png
//  Programozó Páternoszter/PARP
//   https://www.tankonyvtar.hu/hu/tartalom/tamop412A/2011-0063_01_parhuzamos_prog_linux
//
//  https://youtu.be/gvaqijHlRUs
//
#include <iostream>
#include "png++/png.hpp"


#define MERET 600
#define ITER_HAT 32000

void
mandel (int kepadat[MERET][MERET]) {

    float a = -2.0, b = .7, c = -1.35, d = 1.35;
    int szelesseg = MERET, magassag = MERET, iteraciosHatar = ITER_HAT;

    float dx = (b - a) / szelesseg;
    float dy = (d - c) / magassag;
    float reC, imC, reZ, imZ, ujreZ, ujimZ;
	
    int iteracio = 0;
	
    for (int j = 0; j < magassag; ++j)
    {

        for (int k = 0; k < szelesseg; ++k)
        {
            reC = a + k * dx;
            imC = d - j * dy;
            // z_0 = 0 = (reZ, imZ)
            reZ = 0;
            imZ = 0;
            iteracio = 0;
    
            while (reZ * reZ + imZ * imZ < 4 && iteracio < iteraciosHatar)
            {
                // z_{n+1} = z_n * z_n + c
                ujreZ = reZ * reZ - imZ * imZ + reC;
                ujimZ = 2 * reZ * imZ + imC;
                reZ = ujreZ;
                imZ = ujimZ;

                ++iteracio;

            }

            kepadat[j][k] = iteracio;
        }
    }
}

int
main (int argc, char *argv[])
{
    if (argc != 2)
    {
        std::cout << "Hasznalat: ./mandelpng fajlnev";
        return -1;
    }
    int kepadat[MERET][MERET];
    mandel(kepadat);
    png::image < png::rgb_pixel > kep (MERET, MERET);
    for (int j = 0; j < MERET; ++j)
    {
        //sor = j;
        for (int k = 0; k < MERET; ++k)
        {
            kep.set_pixel (k, j,
                           png::rgb_pixel (255 -
                                           (255 * kepadat[j][k]) / ITER_HAT,
                                           255 -
                                           (255 * kepadat[j][k]) / ITER_HAT,
                                           255 -
                                           (255 * kepadat[j][k]) / ITER_HAT));
        }
    }
    kep.write (argv[1]);
    std::cout << argv[1] << " mentve" << std::endl;
}
		]]></programlisting>
		<figure>
				<title>Egy Mandelbrot halmaz</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="Images/mandel1.png" format="png"/>
						</imageobject>
					</mediaobject>
			</figure>
		
		
    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:     <link xlink:href="https://gitlab.com/tocsika7/prog1/blob/master/Mandelbrot/m_komplex.cpp">https://gitlab.com/tocsika7/prog1/blob/master/Mandelbrot/m_komplex.cpp</link>           
        </para>
		<para>
		A program a fenti algoritmus alapján számít és rajzol ki egy Mandelbrot halmazt. A program futásához szükség van a png++ és a complex header-ök meghívására. A programot azzal kezdjük, 
		hogy deklaráljuk a létrehozandó halmaz képének szélességét és magasságát, illetve az iterációs határt. Ezeknek az értékeit parancssori argumentumként fogjuk megadni futtatásnál. 
		</para>
		<programlisting language="c"><![CDATA[
// Verzio: 3.1.2.cpp
// Forditas:
// g++ 3.1.2.cpp -lpng -O3 -o 3.1.2
// Futtatas:
// ./3.1.2 mandel.png 1920 1080 2040 -0.01947381057309366392260585598705802112818 -0.0194738105725413418456426484226540196687 0.7985057569338268601555341774655971676111 0.798505756934379196110285192844457924366
// ./3.1.2 mandel.png 1920 1080 1020 0.4127655418209589255340574709407519549131 0.4127655418245818053080142817634623497725 0.2135387051768746491386963270997512154281 0.2135387051804975289126531379224616102874
// Nyomtatas:
// a2ps 3.1.2.cpp -o 3.1.2.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// ps2pdf 3.1.2.cpp.pdf 3.1.2.cpp.pdf.pdf
//
//
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>



		#include <iostream>
		#include "png++/png.hpp"
		#include <complex>

		int
		main ( int argc, char *argv[] )

		{
    

		int szelesseg = 1920;
		int magassag = 1080;
		int iteraciosHatar = 255;
		double a = -1.9;
		double b = 0.7;
		double c = -1.3;
		double d = 1.3;

		]]></programlisting>
		<para>
		Ellenőrizzük, hogy a futtatáskor megadott argumentumok száma helyes-e,ha igen átadjuk őket a deklarált változóknak, ha nem a program nem fut le és kiírja a helyes futtatási módot. Az atoi() függvénnyel konvertáljuk a megadott
		értékeket int-é és az atof-al pedig double-é. 
		</para>
			<programlisting language="c"><![CDATA[
		if ( argc == 9 )
		{
			szelesseg = atoi ( argv[2] );
			magassag =  atoi ( argv[3] );
			iteraciosHatar =  atoi ( argv[4] );
			a = atof ( argv[5] );
			b = atof ( argv[6] );
			c = atof ( argv[7] );
			d = atof ( argv[8] );
		}
		else
		{
			std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d" << std::endl;
			return -1;
		}
		]]></programlisting>
		<para>
		  
		PNG++ segítségével létrehozzuk a képet, maj egy dupla for ciklussal végigmegyünk a kép 
		szélességén és magasságán és alkalmazzuk a előző feladatban tárgyalt képletet. A c két része lesz 
		a reC és az imC változók míg a z-é a reZ és imZ váltók. Ezekből a complex osztály segítségével készítünk egy-egy komplex számot.
		A képletet addig használjuk amíg a z abszolút értéke kisebb, mint 4 (abs() függvény segítségével) és az iteráció nem érte el az iterációs határt.
		A set_pixel() függvénnyel állítjuk be a halmaz színeit majd a write() függvénnyel el is mentjük a képet. 
		</para>
			<programlisting language="c"><![CDATA[
			png::image < png::rgb_pixel > kep ( szelesseg, magassag );

			double dx = ( b - a ) / szelesseg;
			double dy = ( d - c ) / magassag;
			double reC, imC, reZ, imZ;
			int iteracio = 0;

			std::cout << "Szamitas\n";

			
			for ( int j = 0; j < magassag; ++j )
			{
			

				for ( int k = 0; k < szelesseg; ++k )
				{	

					reC = a + k * dx;
					imC = d - j * dy;
					std::complex<double> c ( reC, imC );

					std::complex<double> z_n ( 0, 0 );
					iteracio = 0;

					while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
					{
						z_n = z_n * z_n + c;

						++iteracio;
					}

					kep.set_pixel ( k, j,
                    png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
				}

				int szazalek = ( double ) j / ( double ) magassag * 100.0;
				std::cout << "\r" << szazalek << "%" << std::flush;
			}

			kep.write ( argv[1] );
			std::cout << "\r" << argv[1] << " mentve." << std::endl;

			}

		]]></programlisting>
				<figure>
				<title>A program egy féle kimenete</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="Images/mandel.png" format="png"/>
						</imageobject>
					</mediaobject>
			</figure>
	
		
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>                        
		
		<para>
		A bimorfok vagy Júlia halmazok bizonyos komplex egyenletek megoldásáinak ábrázolásai a komplex számsíkon. A Mandelbrot halmaz azért különleges,mert tartalmazza az összes ilyen
		halmazt. 
		A Mandelbrot halmaz és a egy Júlia halmaz vagy biomorf megvalósításában a lényeges különbség, hogy a biomorfok esetében a c egy konstans. A C++ megvalósításában nagyon hasonlít a Mandelbrot halmazhoz. 
		A rácspontokon való futás szerepét a z_n veszi át, míg a c-t már csak parancsosri argumentumként fogjuk megadni és a futás során nem változtatunk rajta. A dupla for cikulsban 
		lesz egy harmadik for ciklus amelyben az iterációs határig megyünk el és a halmaz kiszámítására a z<superscript>3</superscript> + c képletet használjuk (erre sok féle képlet 
		létezik amelyek változatos halmazokat adnak). A z_n a pow() függvénnyel emeljük a 3. hatványra.
	</para>
	<para>
	Változás az előző programhoz képest: 
	</para>
		<programlisting language="c"><![CDATA[
		// Verzio: 3.1.3.cpp
// Forditas:
// g++ 3.1.3.cpp -lpng -O3 -o 3.1.3
// Futtatas:
// ./3.1.3 bmorf.png 800 800 10 -2 2 -2 2 .285 0 10
// Nyomtatas:
// a2ps 3.1.3.cpp -o 3.1.3.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// ps2pdf 3.1.3.cpp.pdf 3.1.3.cpp.pdf.pdf
// 
// BHAX Biomorphs
// Copyright (C) 2019
// Norbert Batfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
// https://youtu.be/IJMbgRzY76E
// See also https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf
//

		
		
		for ( int y = 0; y < magassag; ++y )
		{
			for ( int x = 0; x < szelesseg; ++x )
			{
           
				double reZ = xmin + x * dx;
				double imZ = ymax - y * dy;
				std::complex<double> z_n ( reZ, imZ );

				int iteracio = 0;
				for (int i=0; i < iteraciosHatar; ++i)
				{

             
                z_n = std::pow(z_n, 3) + cc;
         
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }
		]]></programlisting>
				<figure>
				<title>Egy a program futtatásával kapott biomorf</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="Images/biomorf.png" format="png"/>
						</imageobject>
					</mediaobject>
			</figure>
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/CUDA/mandelpngc_60x60_100.cu">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/CUDA/mandelpngc_60x60_100.cu</link>    
        </para>
		<para>
			A CUDA-s megvalósítás nagymértékben csökkenti a programok futási idejét. Amíg egy átalános szekvenciális program
			csak a processzor egy szálát használja a végrehajtáshoz, addig a CUDA-s program a GPU szálait használja. A Mandelbrot
			halmaz esetében 60x60-as blokkot hozunk létre és minden blokkban 100 szál fog működni. (600x600-as halmaz). Ez a megoldás 
			körülbelül 50-70-szer gyorsabb megoldást eredményez, mint a szekvenciális. Létrehozzuk a mandelkernel nevű kernelt, ami a CUDA programozásban úgy használtható, mint C-ben egy függvény. Minden szál, ami használja
ezt a kernelt külön azonosítóval rendelkezik, ezek lesznek a tj és tk. Létrehozzuk a j és k blokkokat is, amikbe 10-szer annyi szálat 
helyezünk. A cudamandel függvényben lefoglaljuk a szükséges memóriát a cudaMalloc() függvénnyel. Létrehozzuk a hálót ami dim3 típusú tehát 3 dimenziós. Majd meghívjuk a mandelkernel függvényt. A cudaMemcpy függvénnyel átmásoljuk az adatokat a host memóriából a device memóriába. 
			Majd a cudaFree() függvénnyel felszabadítjuk a memóriát. 
		</para>
		<programlisting language="c"><![CDATA[
// mandelpngc_60x60_100.cu
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
//  Mandelbrot png
//  Programozó Páternoszter/PARP
//   https://www.tankonyvtar.hu/hu/tartalom/tamop412A/2011-0063_01_parhuzamos_prog_linux
//
//  https://youtu.be/gvaqijHlRUs

_global__ void
mandelkernel (int *kepadat)
{

  int tj = threadIdx.x;
  int tk = threadIdx.y;

  int j = blockIdx.x * 10 + tj;
  int k = blockIdx.y * 10 + tk;

  kepadat[j + k * MERET] = mandel (j, k);

}

void
cudamandel (int kepadat[MERET][MERET])
{

  int *device_kepadat;
  cudaMalloc ((void **) &device_kepadat, MERET * MERET * sizeof (int));

  // dim3 grid (MERET, MERET);
  // mandelkernel <<< grid, 1 >>> (device_kepadat);
  
  dim3 grid (MERET / 10, MERET / 10);
  dim3 tgrid (10, 10);
  mandelkernel <<< grid, tgrid >>> (device_kepadat);  
  
  cudaMemcpy (kepadat, device_kepadat,
	      MERET * MERET * sizeof (int), cudaMemcpyDeviceToHost);
  cudaFree (device_kepadat);

}
]]></programlisting>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
            
        <para>
            Megoldás forrása:  <link xlink:href="https://gitlab.com/tocsika7/prog1/tree/master/Mandelbrot/Mandelbrot_Nagyito_C++">https://gitlab.com/tocsika7/prog1/tree/master/Mandelbrot/Mandelbrot_Nagyito_C++</link> 
        </para>

        <para>
            Megoldás videó: 
        </para>
		<para>
		A programot gui-ját QT-ban oldjuk meg ehhez nem 1 programfájlt alkalmazunk, hanem 3 .cpp fájlt 2 headert és egy .pro fajlt. A Frak.pro fájlban a qt-nak adjuk meg a header-öket illetve a forrásfájlokat. 
		</para>
		<para>
		Frak.pro : 
		</para>
		<programlisting language="c"><![CDATA[
		######################################################################
		# Automatically generated by qmake (3.0) Sun Mar 30 10:39:23 2014
		######################################################################

		QT += widgets
		TEMPLATE = app
		TARGET = Frak
		INCLUDEPATH += .

		# Input
		HEADERS += frakablak.h frakszal.h
		SOURCES += frakablak.cpp frakszal.cpp main.cpp
		]]></programlisting>
		<para>
		A következőkben a minden forrásáprogramhoz tartzoik egy külön header fájl, amiben a szükséges osztályokat, illetve függvényeket deklaráljuk. 
		</para>
		<para>
		frakablak.h és frakablak.cpp : 
		</para>
		<para>
		A frakablak fájlban és headerben a halmazt megjelenítő ablakot készítjük el. A program konstruktorában beállítjuk az ablak nevét illetve paramétereit. Minden nagyításnál újraszámítjuk a képet,ezt a paintEvent() QT függvénnyel 
		tesszük. A vissza() függvénnyel a kép színeit állítjuk be. 
		</para>
		<programlisting language="c"><![CDATA[
		// frakablak.cpp
//
// Mandelbrot halmaz rajzoló
// Programozó Páternoszter
//
// Copyright (C) 2011, Bátfai Norbert, nbatfai@inf.unideb.hu, nbatfai@gmail.com
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// Ez a program szabad szoftver; terjeszthetõ illetve módosítható a
// Free Software Foundation által kiadott GNU General Public License
// dokumentumában leírtak; akár a licenc 3-as, akár (tetszõleges) késõbbi
// változata szerint.
//
// Ez a program abban a reményben kerül közreadásra, hogy hasznos lesz,
// de minden egyéb GARANCIA NÉLKÜL, az ELADHATÓSÁGRA vagy VALAMELY CÉLRA
// VALÓ ALKALMAZHATÓSÁGRA való származtatott garanciát is beleértve.
// További részleteket a GNU General Public License tartalmaz.
//
// A felhasználónak a programmal együtt meg kell kapnia a GNU General
// Public License egy példányát; ha mégsem kapta meg, akkor
// tekintse meg a <http://www.gnu.org/licenses/> oldalon.
//
//
// Version history:
//
// 0.0.1    Bár a Nokia Qt SDK éppen tartalmaz egy Mandelbrotos példát, de
// ezt nem tartottam megfelelõnek elsõ Qt programként ajánlani, mert elég
// bonyolult: használ kölcsönös kizárást stb. Ezért "from scratch" megírtam
// egy sajátot a Javát tanítokhoz írt dallamára:
// http://www.tankonyvtar.hu/informatika/javat-tanitok-2-2-080904-1
//

#include "frakablak.h"

FrakAblak::FrakAblak(double a, double b, double c, double d,
                     int szelesseg, int iteraciosHatar, QWidget *parent)
                         : QMainWindow(parent)
{
    setWindowTitle("Mandelbrot halmaz");

    int magassag = (int)(szelesseg * ((d-c)/(b-a)));

    setFixedSize(QSize(szelesseg, magassag));
    fraktal= new QImage(szelesseg, magassag, QImage::Format_RGB32);

    mandelbrot = new FrakSzal(a, b, c, d, szelesseg, magassag, iteraciosHatar, this);
    mandelbrot->start();

}

FrakAblak::~FrakAblak()
{
    delete fraktal;
    delete mandelbrot;
}

void FrakAblak::paintEvent(QPaintEvent*) {
    QPainter qpainter(this);
    qpainter.drawImage(0, 0, *fraktal);
    qpainter.end();
}

void FrakAblak::vissza(int magassag, int *sor, int meret, int hatar)
{
    for(int i=0; i<meret; ++i) {
        //        QRgb szin = qRgb(0, 255-sor[i], 0);
        QRgb szin;
        if(sor[i] == hatar)
            szin = qRgb(0,0,0);
        else
            szin = qRgb(
                    255-sor[i],
                    255-sor[i]%64,
                    255-sor[i]%16 );

        fraktal->setPixel(i, magassag, szin);
    }
    update();
}

		]]></programlisting>
        <para>
		frakszal.h és frakszal.cpp
		</para>
		<para>
		A frakszal.cpp fájlban a konstruktorban szükséges változókat állítjuk be. A run() függvényben pedig a halmazt létrehozó már az előző programokban tárgyalt számítás zaljik.
		A szinezést nem itt végezzük, hanem a frakablak programban, illetve az adott iterációt is a vissza függvénnyel átadjuk a frakablak forrásnak hogy az ki tudja rajzolni. 
		</para>
		<programlisting language="c"><![CDATA[
		// frakszal.cpp
//
// Mandelbrot halmaz rajzoló
// Programozó Páternoszter
//
// Copyright (C) 2011, Bátfai Norbert, nbatfai@inf.unideb.hu, nbatfai@gmail.com
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// Ez a program szabad szoftver; terjeszthetõ illetve módosítható a
// Free Software Foundation által kiadott GNU General Public License
// dokumentumában leírtak; akár a licenc 3-as, akár (tetszõleges) késõbbi
// változata szerint.
//
// Ez a program abban a reményben kerül közreadásra, hogy hasznos lesz,
// de minden egyéb GARANCIA NÉLKÜL, az ELADHATÓSÁGRA vagy VALAMELY CÉLRA
// VALÓ ALKALMAZHATÓSÁGRA való származtatott garanciát is beleértve.
// További részleteket a GNU General Public License tartalmaz.
//
// A felhasználónak a programmal együtt meg kell kapnia a GNU General
// Public License egy példányát; ha mégsem kapta meg, akkor
// tekintse meg a <http://www.gnu.org/licenses/> oldalon.
//
//
// Version history:
//
// 0.0.1    Bár a Nokia Qt SDK éppen tartalmaz egy Mandelbrotos példát, de
// ezt nem tartottam megfelelõnek elsõ Qt programként ajánlani, mert elég
// bonyolult: használ kölcsönös kizárást stb. Ezért "from scratch" megírtam
// egy sajátot a Javát tanítokhoz írt dallamára:
// http://www.tankonyvtar.hu/informatika/javat-tanitok-2-2-080904-1
//

#include "frakszal.h"

FrakSzal::FrakSzal(double a, double b, double c, double d,
                   int szelesseg, int magassag, int iteraciosHatar, FrakAblak *frakAblak)
{
    this->a = a;
    this->b = b;
    this->c = c;
    this->d = d;
    this->szelesseg = szelesseg;
    this->iteraciosHatar = iteraciosHatar;
    this->frakAblak = frakAblak;
    this->magassag = magassag;

    egySor = new int[szelesseg];
}

FrakSzal::~FrakSzal()
{
    delete[] egySor;
}

// A szál kódját a Javát tanítokhoz írt Java kódomból vettem át
// http://www.tankonyvtar.hu/informatika/javat-tanitok-2-2-080904-1
// mivel itt az algoritmust is leírtam/lerajzoltam, így meghagytam
// a kommenteket, hogy a hallgató könnyen hozzáolvashassa az "elméletet",
// ha érdekli.
void FrakSzal::run()
{
    // A [a,b]x[c,d] tartományon milyen sûrû a
    // megadott szélesség, magasság háló:
    double dx = (b-a)/szelesseg;
    double dy = (d-c)/magassag;
    double reC, imC, reZ, imZ, ujreZ, ujimZ;
    // Hány iterációt csináltunk?
    int iteracio = 0;
    // Végigzongorázzuk a szélesség x magasság hálót:
    for(int j=0; j<magassag; ++j) {
        //sor = j;
        for(int k=0; k<szelesseg; ++k) {
            // c = (reC, imC) a háló rácspontjainak
            // megfelelõ komplex szám
            reC = a+k*dx;
            imC = d-j*dy;
            // z_0 = 0 = (reZ, imZ)
            reZ = 0;
            imZ = 0;
            iteracio = 0;
            // z_{n+1} = z_n * z_n + c iterációk
            // számítása, amíg |z_n| < 2 vagy még
            // nem értük el a 255 iterációt, ha
            // viszont elértük, akkor úgy vesszük,
            // hogy a kiinduláci c komplex számra
            // az iteráció konvergens, azaz a c a
            // Mandelbrot halmaz eleme
            while(reZ*reZ + imZ*imZ < 4 && iteracio < iteraciosHatar) {
                // z_{n+1} = z_n * z_n + c
                ujreZ = reZ*reZ - imZ*imZ + reC;
                ujimZ = 2*reZ*imZ + imC;
                reZ = ujreZ;
                imZ = ujimZ;

                ++iteracio;

            }
            // ha a < 4 feltétel nem teljesült és a
            // iteráció < iterációsHatár sérülésével lépett ki, azaz
            // feltesszük a c-rõl, hogy itt a z_{n+1} = z_n * z_n + c
            // sorozat konvergens, azaz iteráció = iterációsHatár
            // ekkor az iteráció %= 256 egyenlõ 255, mert az esetleges
            // nagyítasok során az iteráció = valahány * 256 + 255


            //a színezést viszont már majd a FrakAblak osztályban lesz
            egySor[k] = iteracio;
        }
        // Ábrázolásra átadjuk a kiszámolt sort a FrakAblak-nak.
        frakAblak->vissza(j, egySor, szelesseg, iteraciosHatar);
    }
}

		]]></programlisting>
		<para>
		A fordítás: 
		</para>
		<programlisting><![CDATA[
		qmake Frak.pro
		make Frak
		./Frak
		]]></programlisting>
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
		 A Mandelbrot nagyítót java-ban úgy oldjuk meg, hogy egy java-s Mandelbrot halmaz megvalósítás osztályát terjesztjük ki. 
        </para>
		<para>
            Megoldás forrása:  <link xlink:href="https://gitlab.com/tocsika7/prog1/blob/master/Mandelbrot/MandelbrotHalmazNagyito.java">https://gitlab.com/tocsika7/prog1/blob/master/Mandelbrot/MandelBrotHalmazNagyito.java</link>   
        </para>
		<programlisting><![CDATA[
			/*
 * MandelbrotHalmazNagyito.java
 *
 * DIGIT 2005, Javat tanitok
 * Batfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A Mandelbrot halmazt nagyito es kirajzolo osztaly.
 *
 * @author Batfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.2
 */
public class MandelbrotHalmazNagyito extends MandelbrotHalmaz {
    /** A nagyitando kijelolt teruletet bal felso sarka. */
    private int x, y;
    /** A nagyitando kijelolt terulet szelessege es magassaga. */
    private int mx, my;
    /**
     * Letrehoz egy a Mandelbrot halmazt a komplex sik
     * [a,b]x[c,d] tartomanya felett kiszamolo es nygitani tudo
     * <code>MandelbrotHalmazNagyito</code> objektumot.
     *
     * @param      a              a [a,b]x[c,d] tartomany a koordinataja.
     * @param      b              a [a,b]x[c,d] tartomany b koordinataja.
     * @param      c              a [a,b]x[c,d] tartomany c koordinataja.
     * @param      d              a [a,b]x[c,d] tartomany d koordinataja.
     * @param      szelesseg      a halmazt tartalmazo tomb szelessege.
     * @param      iteraciosHatar a szamitas pontossaga.
     */
    public MandelbrotHalmazNagyito(double a, double b, double c, double d,
            int szelesseg, int iteraciosHatar) {
        // Az os osztaly konstruktoranak hivasa
        super(a, b, c, d, szelesseg, iteraciosHatar);
        setTitle("A Mandelbrot halmaz nagyitasai");
	]]></programlisting>
		<para>
			A a nagyítandó területet a bal egérgombbal tudjuk kijelölni. Az egér kattintásait egy listener segítségével dolgozzuk fel. 
			Majd megnézzük hol van a mutató pozíciója. A kijelölő tégalap bal felső sarkának a koordinátái az x és y tagjai az osztálynak, 
			míg a az mx és my a téglalap magasssága és szélessége. A mousepressed() függvényben ezeket az adatokat kérjük le.
			Az mx és my-t 0-ra állítjuk és majd akkor fogjuk növelni ha a téglalapot vonszoljuk. A vonszolás mértékét egy egér mozgását érzékelő
			listener-rel kapjuk meg.Ha felengedjük az egeret újrakezdi a számolást és csinál egy új objektumot. 
			Ha kivonjuk téglalap x és y koordinátáiból az egérmutató aktuális helyzetét akkor megkapjuk 
			a kirajzolandó tégallap kellő méreteit. A repaint() hívás gondoskodik arról, hogy a megfeleő téglalap legyen kirajzolva.
			
		</para>
		<programlisting><![CDATA[
        addMouseListener(new java.awt.event.MouseAdapter() {
            // Eger kattintassal jeloljuk ki a nagyitando teruletet
            // bal felso sarkat vagy ugyancsak eger kattintassal
            // vizsgaljuk egy adott pont iteracioit:
		public void mousePressed(java.awt.event.MouseEvent m) {
                // Az egermutato pozicioja
                x = m.getX();
                y = m.getY();
                // Az 1. eger gombbal a nagyitando terulet kijeloleset
                // vegezzuk:
                if(m.getButton() == java.awt.event.MouseEvent.BUTTON1 ) {
                    // A nagyitando kijelolt teruletet bal felso sarka: (x,y)
                    // es szelessege (majd a vonszolas noveli)
                    mx = 0;
                    my = 0;
                    repaint();
                } else {
                    // Nem az 1. eger gombbal az egermutato mutatta c
                    // komplex szambol inditott iteraciokat vizsgalhatjuk
                    MandelbrotIteraciok iteraciok =
                            new MandelbrotIteraciok(
                            MandelbrotHalmazNagyito.this, 50);
                    new Thread(iteraciok).start();
                }
            }
            // Vonszolva kijelolunk egy teruletet...
            // Ha felengedjuk, akkor a kijelolt terulet
            // ujraszamitasa indul:
            public void mouseReleased(java.awt.event.MouseEvent m) {
                if(m.getButton() == java.awt.event.MouseEvent.BUTTON1 ) {
                    double dx = (MandelbrotHalmazNagyito.this.b
                            - MandelbrotHalmazNagyito.this.a)
                            /MandelbrotHalmazNagyito.this.szelesseg;
                    double dy = (MandelbrotHalmazNagyito.this.d
                            - MandelbrotHalmazNagyito.this.c)
                            /MandelbrotHalmazNagyito.this.magassag;
                    // Az uj Mandelbrot nagyito objektum elkeszitese:
                    new MandelbrotHalmazNagyito(
                            MandelbrotHalmazNagyito.this.a+x*dx,
                            MandelbrotHalmazNagyito.this.a+x*dx+mx*dx,
                            MandelbrotHalmazNagyito.this.d-y*dy-my*dy,
                            MandelbrotHalmazNagyito.this.d-y*dy,
                            600,
                            MandelbrotHalmazNagyito.this.iteraciosHatar)
                }
            }
        });
        // Eger mozgas esemenyek feldolgozasa:
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            // Vonszolassal jeloljuk ki a negyzetet:
            public void mouseDragged(java.awt.event.MouseEvent m) {
                // A nagyitando kijelolt terulet szelessege es magassaga:
                mx = m.getX() - x;
                my = m.getY() - y;
                repaint();
            }
        });
    }
]]></programlisting>
		
		<para>
			Ezután kidolgozzuk a pillanatkép készítő funkciót. Kirajzoljuk a területet jelző tégalalapot és visszaadjuk az egérmutató
			akutális helyzetét. A main()-ben ezek után csak példányosítunk egy MandelBrotHalmazNagyito objektumot. 
		</para>
			   <programlisting><![CDATA[
 /**
     * Pillanatfelvetelek keszitese.
     */
    public void pillanatfelvetel() {
        // Az elmentendo kep elkeszitese:
        java.awt.image.BufferedImage mentKep =
                new java.awt.image.BufferedImage(szelesseg, magassag,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        java.awt.Graphics g = mentKep.getGraphics();
        g.drawImage(kep, 0, 0, this);
        g.setColor(java.awt.Color.BLACK);
        g.drawString("a=" + a, 10, 15);
        g.drawString("b=" + b, 10, 30);
        g.drawString("c=" + c, 10, 45);
        g.drawString("d=" + d, 10, 60);
        g.drawString("n=" + iteraciosHatar, 10, 75);
        if(szamitasFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);
        g.dispose();
        // A pillanatfelvetel kepfajl nevenek kepzese:
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("MandelbrotHalmazNagyitas_");
        sb.append(++pillanatfelvetelSzamlalo);
        sb.append("_");
        // A fajl nevebe belevesszuk, hogy melyik tartomanyban
        // talaltuk a halmazt:
        sb.append(a);
        sb.append("_");
        sb.append(b);
        sb.append("_");
        sb.append(c);
        sb.append("_");
        sb.append(d);
        sb.append(".png");
        // png formatumu kepet mentunk
        try {
            javax.imageio.ImageIO.write(mentKep, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
    /**
     * A nagyitando kijelolt teruletet jelzo negyzet kirajzolasa.
     */
    public void paint(java.awt.Graphics g) {
        // A Mandelbrot halmaz kirajzolasa
        g.drawImage(kep, 0, 0, this);
        // Ha eppen fut a szamitas, akkor egy voros
        // vonallal jeloljuk, hogy melyik sorban tart:
        if(szamitasFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }
        // A jelzo negyzet kirajzolasa:
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);
    }
    /**
     * Hol all az egermutato?
     * @return int a kijelolt pont oszlop pozicioja.
     */    
    public int getX() {
        return x;
    }
    /**
     * Hol all az egermutato?
     * @return int a kijelolt pont sor pozicioja.
     */    
    public int getY() {
        return y;
    }
    /**
     * Peldanyosit egy Mandelbrot halmazt nagyito obektumot.
     */
    public static void main(String[] args) {
        // A kiindulo halmazt a komplex sik [-2.0, .7]x[-1.35, 1.35]
        // tartomanyaban keressuk egy 600x600-as haloval es az
        // aktualis nagyitasi pontossaggal:
        new MandelbrotHalmazNagyito(-2.0, .7, -1.35, 1.35, 600, 255);
    }
}                    
]]></programlisting>
	<figure>
				<title>Egy 4-szeres nagyítás folyamata</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="Images/mandelnagyito.png" format="png"/>
						</imageobject>
					</mediaobject>
			</figure>
			<figure>
				<title>Egy 13-szoros nagyítás</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="Images/13szoros.png" format="png"/>
						</imageobject>
					</mediaobject>
			</figure>
		
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
