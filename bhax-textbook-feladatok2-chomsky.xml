<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>

        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Encoding</title>
        <para>Megoldás forrás:<link xlink:href="https://gitlab.com/tocsika7/prog2_forrasok/tree/master/Chomsky/Encoding">GitLab</link> </para>
        <para>Tanulságok, tapasztalatok, magyarázat...</para>
        <para>A feladat az volt, hogy a Mandelbort Halmaz nagyító programját fordítsuk és futtassuk
            úgy, hogy mind a kódban és a fájlnévben meghagyjuk az ékezetes karaktereket. </para>
        <para>Ha, ezt a szoksásos módon próbáljuk meg, akkor kapjuk a hibaüzeneteket, hogy az UTF-8
            számára ismeretlen karaktereket tartalmaz a kódunk. </para>
        <informalfigure>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Images/encoding_errors.png"/>
                </imageobject>
            </mediaobject>
        </informalfigure>
        <para>A javac dokumentációban látható, hogy a -encoding kapcsolóval lehet jelezni a
            fordítónak, hogy nem a szokásos kódolással van dolga. </para>
        <informalfigure>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Images/encoding_doc.png"/>
                </imageobject>
            </mediaobject>
        </informalfigure>
        <para>Ezt követően a wikipédián megkerestem, mi a magyar ékezetes karakterek kódolása. Ezek
            a karakterek az ISO/IEC 8859-2 (Latin-2) karakterkészletében találhatóak meg.  </para>
        <para>Az Oracle oldalán megnéztem, hogy a java.lang API-ban, ez hogyan van jelölve, majd az
            encoding kapcsolónak így adtam meg és a program hiba nélkül fordult, futott. </para>
        <informalfigure>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Images/encoding_latin2.png"/>
                </imageobject>
            </mediaobject>
        </informalfigure>
        <informalfigure>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Images/encoding_comp.png"/>
                </imageobject>
            </mediaobject>
        </informalfigure>
        <figure>
            <title>A program futásokor készített screenshot</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Images/encoding_Sc.png"/>
                </imageobject>
            </mediaobject>
        </figure>
    	
    </section>    
    <section>
        <title>Saját Leet Cipher</title>
        <para> Megoldás forrása:<link xlink:href="https://gitlab.com/tocsika7/prog2_forrasok/tree/master/Chomsky/leet.cpp">GitLab</link> </para>
        <para> Tanulságok, tapasztalatok, magyarázat...</para>
        <para>A feladat az, volt hogy lexer használata nélkül írjunk egy programot ami átkonvertálja
            a kapott szövegett leet szöveggé. </para>
        <para>A feladathoz a karakterek ASCII kódolását használtam alapul. Minden karakter mögött
            van egy decimális érték, amikor integer-é kényszírtjük őket ezt azt értéket kapjuk. Az
            angol ABC betűinél ez az érték A-Z-ig 65-99, illetve 0-9 ig a számoknál 48-57. </para>
        <para>A leet osztályban private részében létrehozunk a leet karaktereket tartalmazó tömböket
            az angol ABC betűire, illetve a számokra. A cipher függvény bekér egy integer értéket
            (az adott karakterét) , majd megnézi hogy melyik tartományban van, és eszerint adja
            vissza leet tömbök egyikéből, azt az értéket amelyik hozzá tartozik. Ezt úgy érjük el
            hogy a megadott értékből kivonjuk a tartomány kezdő értékét. Például a T betű értéke 84,
            ekkor ebből kivonjuk a 65-öt és visszadjuk a karaktereket tartalmazó tömb 19. elemét ami
            a T betűhöz tartazó leet karaktert tartalmazza. </para>
        <para>Az input és outputot fájlkezeléssel oldjuk meg. A be- és kifile-okat argumentumként
            kell megadni, ha nem így teszünk leáll a program és kiírja a helyes használatot.
            Példányosítunk egy leet objektumot. A befile tartalmát beolvassuk egy segéd stringbe.
            Majd ezt a stringet bemásoljuk egy output char tömbbe a strcpy() függvénnyel. Ezután a
            kifile-ba karakterenként beírjuk az output tömb elemeit, de előtte meghívjuk rá a cipher
            függvényt és azért hogy ez sikeresen működjön a toupper() függvénnyel átkonvertáljuk
            őket nagybetűre majd típuskényszerítjük őket integer-re. </para>
        <para>A kód:
            <programlisting>#include &lt;iostream>
#include &lt;fstream>
#include &lt;string.h>
#include &lt;stdio.h>

class leet
{
private:
    std::string leetchars[26]{
        "4", "8", "&lt;", "[)", "3", "|=", "6", "|-|", "1", "_|", "|&lt;", "|", "|V|", "|\\|", "O",
        "|>", "0.", "|2", "5", "7", "|_|", "\\/", "\\X/", "}{", "`/", "2"};

    std::string leetnums[10]{
        "O", "I", "Z", "E", "A", "S", "G", "T", "B", "g"};

public:
    std::string cipher(int ch)
    {
        if (ch >= 65 &amp;&amp; ch &lt;= 90)
        {
            return leetchars[ch - 65];
        }
        else if (ch >= 48 &amp;&amp; ch &lt;= 57)
        {
            return leetnums[ch - 48];
        }
        else
        {
            return std::to_string(ch);
        }
    }
};

int main(int argc, char *argv[])
{
    if (argc != 3)
    {
        std::cout &lt;&lt; "Használat: ./leet input.txt output.txt \n";
        return -1;
    }

    std::ifstream befile(argv[1]);
    std::ofstream kifile(argv[2]);

    leet l;
    std::string temp;

    while (!befile.eof())
    {
        befile >> temp;
    }

    char output[temp.length() + 1];
    strcpy(output, temp.c_str());

    for (int i = 0; i &lt; temp.length(); i++)
    {
        kifile &lt;&lt; (l.cipher((int)(toupper(output[i]))));
    }

    befile.close();
    kifile.close();

    return 0;
}</programlisting></para>
        <para>A program futása:</para>
        <para><inlinemediaobject>
                <imageobject>
                    <imagedata fileref="Images/leet.png"/>
                </imageobject>
            </inlinemediaobject></para>
    </section>    
    
     <section>
        <title>Full Screen</title>
        <para>Megoldás forrása: <link
                xlink:href="https://gitlab.com/tocsika7/prog2_forrasok/tree/master/Chomsky/FullScreen"
                >GitLab</link>
        </para>
        <para>Tanulások, tapasztalatok, magyarázat...</para>
        <para>A feladat az volt, hogy keszítsünk egy Java programot, ami Full Screen-ben fut. </para>
        <para>A megoldásra a Bátfai Norbert Tanár Úr által készített Labirintus játékot használtam.
            A játék működéset nem részletezem,mert a feladatban csak a teljesképernyős módon van a
            hangsúly. </para>
        <para>A <emphasis role="bold">LabirintusJáték.java</emphasis> fájl kódrészleteinek
            magyarázata:</para>
        <para>Az osztály a java Frame osztályát egészíti ki, ami lényegében adja, az ablakos
            rendszert. A GraphicsDevice osztályból példányostítunk egy objektumot. Ez az osztály
            azokat a grafikus eszközöket adja meg, amelyek használhatóak az adott grafikus
            környezethez. Ezeket a getLocalGraphicsEnviroment() metódussal kérjük le, az
            alapértelmezett képernyőt pedig a getDefaulScreenDevice() metódussal. </para>
        <programlisting>public class LabirintusJáték extends java.awt.Frame
        implements Runnable {
.
.
.
java.awt.GraphicsDevice graphicsDevice;
.
.
java.awt.GraphicsEnvironment graphicsEnvironment = java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment();
.
.
graphicsDevice = graphicsEnvironment.getDefaultScreenDevice();
.
.
teljesKépernyősMód(graphicsDevice);</programlisting>
        <para>A Full Screen beállítását a teljesKépernyősMód() metódusban végezzük el. A szélesség
            és magasság változókat kinullázzuk, mert az ablaknak "nincsen kerete". A setResizable()
            metódusal kikapcsoljuk az átméretehetőséget. Lekérdezzük támogatott-e a Full Screen mód,
            ha igen,ezt az isFullScreenSupported() metódussal teszzük.Ha támogatott akkor átadjuk a
            setFullScreenWindow() metódusnak a képernyő tulajdonságait. Ezt a this referenciával
            adjuk át. A támogatott felbontásokat egy tömbbe kérjük le.A képernyő tulajdonságait mint
            a szélesség, magasság, színmélység, bitmélység és frissitési frekvenica változókban
            tárljuk el, és ezeket a tulajdonságokat majd megjelenítjük a képernyő sarkában. A
            támogatott felbonásokat egy tömbben tároljuk el. Megnézzük az adott felbontás
            támogatott-e (itt 1920x1080), ha igen ezt állítjuk be a felbontásnak, ha nem kiírjuk,
            hogy a felbontás nem lesz jó a játékhoz. </para>
        <programlisting>    public void teljesKépernyősMód(java.awt.GraphicsDevice graphicsDevice) {
        
        int szélesség = 0;
        int magasság = 0;
        setUndecorated(true);
        setIgnoreRepaint(true);
        setResizable(false);
        boolean fullScreenTamogatott = graphicsDevice.isFullScreenSupported();
        if(fullScreenTamogatott) {
            graphicsDevice.setFullScreenWindow(this);
            java.awt.DisplayMode displayMode
                    = graphicsDevice.getDisplayMode();
            szélesség = displayMode.getWidth();
            magasság = displayMode.getHeight();
            int színMélység = displayMode.getBitDepth();
            int frissítésiFrekvencia = displayMode.getRefreshRate();
            System.out.println(szélesség
                    + "x"  + magasság
                    + ", " + színMélység
                    + ", " + frissítésiFrekvencia);
            java.awt.DisplayMode[] displayModes
                    = graphicsDevice.getDisplayModes();
            boolean dm1024x768 = false;
            for(int i=0; i&lt;displayModes.length; ++i) {
                if(displayModes[i].getWidth() == 1920
                        &amp;&amp; displayModes[i].getHeight() == 1080
                        &amp;&amp; displayModes[i].getBitDepth() == színMélység
                        &amp;&amp; displayModes[i].getRefreshRate() 
                        == frissítésiFrekvencia) {
                    graphicsDevice.setDisplayMode(displayModes[i]);
                    dm1024x768 = true;
                    break;
                }
                
            }
            
            if(!dm1024x768)
                System.out.println("Nem megy az 1024x768, de a példa képméretei ehhez a felbontáshoz vannak állítva.");</programlisting>
        <para><emphasis role="bold">A program futtatása: </emphasis></para>
        <para><code>javac javattanitok/labirintus/*.java</code></para>
        <para><code>javac javattanitok/LabirintusJáték.java</code></para>
        <para><code>java javattanitok.LabirintusJáték labirintus.txt</code></para>
        <para><emphasis role="bold">Futás 1920x1080-as felbontással: </emphasis></para>
        <informalfigure>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Images/fullscreen.png"/>
                </imageobject>
            </mediaobject>
        </informalfigure>
    </section>
    
</chapter>                
